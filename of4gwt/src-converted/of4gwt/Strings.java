/**
 * Copyright (c) ObjectFabric Inc. All rights reserved.
 *
 * This file is part of ObjectFabric (objectfabric.com).
 *
 * ObjectFabric is licensed under the Apache License, Version 2.0, the terms
 * of which may be found at http://www.apache.org/licenses/LICENSE-2.0.html.
 *
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

package of4gwt;

public final class Strings { // TODO clean, use only for core

    public static final String CURRENT_NULL = "Current transaction is null. This generally means this operation requires you to start a transaction explicitly.";

    public static final String AUTO_COMMIT_DISABLED = CURRENT_NULL + " Also, auto commit is disabled (C.f. CompileTimeSettings.AUTO_TRANSACTIONS).";

    public static final String AUTO_COMMIT_FAILED = "Last operation could not be comitted.";

    public static final String TRANSACTION_NOT_CURRENT;

    public static final String CANNOT_COMMIT_OR_ABORT_A_TRUNK = "Trunk transactions cannot be committed or aborted.";

    public static final String READ_ONLY_OR_COMMITTED = "Transaction has already been committed or is read only. This might happens when executing a listener or callback with Granularity ALL. To modify an object in this case, call Transaction.setCurrent(null) first to get out of the committed transaction.";

    public static final String CANNOT_SWITCH_NOT_SUSPENDED = "Current thread cannot switch to this transaction because another thread is already running in its context.";

    public static final String PUBLIC_TRANSACTION_CHANGED = "Current public transaction changed since the method was called.";

    public static final String TOO_MANY_PENDING_METHODS;

    public static final String THREAD_BLOCKING_DISALLOWED = "Blocking is disallowed (CompileTimeSettings.DISALLOW_BLOCKING = true). If this is a GWT application, make sure you are using only asynchronous methods.";

    public static final String ONLY_ON_LOCAL = "This method can be called only on the local site.";

    public static final String ONLY_ON_ORIGIN = "This method can be called only on the site where this object has been created.";

    public static final String ONLY_ON_ORIGIN_OR_TARGET = ONLY_ON_ORIGIN + " For connections, it can also be called on target site.";

    public static final String CANNOT_CONNECT_TO_SELF = "A site cannot connect to itself.";

    public static final String UNKNOWN_OBJECT_MODEL;

    public static final String UNKNOWN_ELEMENT_TYPE = "Unknown element type for this array or collection: ";

    public static final String MISSING_METHOD_CALL_IMPLEMENTATION;

    public static final String MISSING_CUSTOM_SERIALIZER = "Missing custom serializer. OF cannot deserialize data that has been serialized using a custom serialializer (OF.getCustomSerializer()).";

    public static final String CLASS_VISITOR_ID_ALREADY_REGISTERED = "This class visitor ID is already registered.";

    public static final String USER_CODE_CHANGED_CURRENT_TRANSACTION;

    public static final String USER_CODE_RAISED_AN_EXCEPTION = "User code raised an exception: ";

    public static final String ITERATORS;

    public static final String ARGUMENT_NULL = "Argument cannot be null.";

    public static final String ALREADY_STARTED = "Already started.";

    public static final String ALREADY_REGISTERED = "Already registered.";

    public static final String NOT_STARTED = "Not started.";

    public static final String NOT_STARTED_OR_REMOTE = "This store is either not started or remote.";

    public static final String NOT_REGISTERED = "Not registered.";

    public static final String ONLY_ONCE = "This method can only be called once.";

    public static final String WRONG_OBJECTFABRIC_VERSION = "Trying to register an object model generated by a different version of ObjectFabric.";

    public static final String WRONG_TRUNK = "Transaction tries to access an object belonging to another trunk. Make sure you specify the right trunk when starting a transaction, or call Transaction.setDefault(trunk) beforehand. Also make sure you do not span a transaction over objects belonging to different trunks.";

    public static final String WRONG_STORE = "Object cannot be added to the store, its trunk is not persistent or persisted to another store. Make sure the object belong to a compatible trunk, either by passing the trunk as constructor, or by calling Transaction.setDefault(trunk) before creating objects. In addition, the trunk must have been created using Site.createTrunk(store). ";

    public static final String DISCONNECTED_BRANCH = "Connection has been lost with this object for the current transaction.";

    public static final String EXCEPTION_ON_USER_METHOD = "An exception has been thrown by a user method, invoking 'setException' callback for this method.";

    public static final String NO_CALLBACK_FOR_EXCEPTION = "No callback were provided by the user to report this exception, logging it: ";

    public static final String CORRUPTED_STORE = "This store is corrupted and cannot be read.";

    public static final String INVALID_FLAGS = "Invalid transaction flags, see Transaction.START_FLAGS.";

    public static final String REMOTE_METHOD_CALL = "Transactions cannot be committed or aborted during a remote method call.";

    public static final String NOT_A_TRUNK = "Transactions must be a trunk.";

    public static final String DELETE_FILE_FAILED = "Could not delete file: ";

    public static final String SESSION_EXPIRED = "Session expired.";

    public static final String SESSION_RETRY = "Session retry.";

    public static final String INVALID_MAGIC_NUMBER = "Invalid magic number on connection. If you are accepting HTTP connections, make sure you added the HTTP filter.";

    public static final String SSLENGINE_CLOSED = "SSLEngine closed";

    /**
     * Concurrent reads or write to http connection. Should not happen as clients do not
     * retry. They would create a new session instead even if it means downloading objects
     * again. There is no sequence number or other validation mechanism so it would not be
     * safe to retry.
     */
    public static final String CONCURRENT_ACCESS = "Concurrent http connection.";

    public static final String FATAL_ERROR = "Fatal error, killing process.";

    static {
        String message;

        message = "This transaction is not running on the current thread. It has probably already ";
        message += "been committed or aborted, or the current thread switched to another transaction.";
        TRANSACTION_NOT_CURRENT = message;

        message = "Too many pending methods. In GWT a thread cannot block so you must test manually if ";
        message += "getPendingMethodCallCount() < Connection.MAX_PENDING_METHOD_CALLS on the connection with ";
        message += "the server before calling a method a transaction.";
        TOO_MANY_PENDING_METHODS = message;

        message = "Unknown object model. You must register the object model you generated on all the ";
        message += "sites where it is used. This error usually occurs when an object model has been ";
        message += "regenerated, or if the version of ObjectFabric is different between two sites.";
        UNKNOWN_OBJECT_MODEL = message;

        message = "You must override this method in a derived class to";
        message += " provide an implementation, then use the derived class when";
        message += " you want to share instances. If you already provided the implementation";
        message += " on another site, specify explicitely this site as executor when calling";
        message += " the method to run the method remotely.";
        MISSING_METHOD_CALL_IMPLEMENTATION = message;

        message = "User code changed the current transaction. Your method either started a transaction and did not commit it, ";
        message += "or called Transaction.setCurrent(transaction) and did not restore the original current transaction.";
        USER_CODE_CHANGED_CURRENT_TRANSACTION = message;

        message = "Iterators on transactional collections cannot be used without a private transaction. You must start a ";
        message += "transaction and keep it running until you are done using the iterator. This is necessary as iterators ";
        message += "need a stable view of the collection. Alternativelly, you can create a Config to start a transaction ";
        message += "for you (C.f. of4gwt.OF.Config)";
        ITERATORS = message;
    }
}