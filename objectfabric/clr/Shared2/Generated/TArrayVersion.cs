/**
 * This file is part of ObjectFabric (http://objectfabric.org).
 *
 * ObjectFabric is licensed under the Apache License, Version 2.0, the terms
 * of which may be found at http://www.apache.org/licenses/LICENSE-2.0.html.
 * 
 * Copyright ObjectFabric Inc.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

namespace org.objectfabric {

//==============================================================================
//                                                                              
//  THIS FILE HAS BEEN GENERATED BY OBJECTFABRIC                                        
//                                                                              
//==============================================================================

sealed class TArrayVersion<T> : TIndexed.VersionN {

    static readonly bool IS_TOBJECT = ObjectFabric.TType.IsTObject(typeof(T));

    private T[][] _values;

    public TArrayVersion(int length)
        : base(length) {

        if (length > 0) {
            // Preallocate (C.f. TIndexedNVersion._writes)
            int arrayLength = getBits().Length;
            _values = new T[arrayLength][];
        }
    }

    T[][] getValues() {
        return _values;
    }

    void setValues(T[][] value) {
        _values = value;
    }

    public T get(int index) {
        if (_values != null) {
            int foldedIndex = org.objectfabric.Bits.getFoldedIntIndexFromIndex(getBits(), index);

            if (foldedIndex >= 0) {
                T[] current = _values[foldedIndex];

                if (current != null)
                    return current[index & org.objectfabric.Bits.BIT_INDEX_MASK];
            }
        }

        return default(T);
    }

    public override object getAsObject(int index) {
        return get(index);
    }

    public void set(int index, T value) {
        if (_values == null) {
            if (value != null && !value.Equals(default(T))) {
                int arrayLength = getBits().Length;
                _values = new T[arrayLength][];
            }
        } else {
            if (org.objectfabric.Debug.ENABLED)
                org.objectfabric.Debug.assertion(_values.Length == getBits().Length);
        }

        if (_values != null) {
            int folded = org.objectfabric.Bits.getFoldedIntIndexFromIndex(getBits(), index);

            if (_values[folded] == null) {
                if (value != null && !value.Equals(default(T))) {
                    int arrayLength = org.objectfabric.Bits.BITS_PER_UNIT;
                    _values[folded] = new T[arrayLength];
                }
            }

            if (_values[folded] != null)
                _values[folded][index & org.objectfabric.Bits.BIT_INDEX_MASK] = value;
        }
    }

    // @SuppressWarnings("cast")
    public override void setAsObject(int index, object value) {
        set(index, (T) value);
    }

    internal override void reindexed(org.objectfabric.Bits.Entry[] old) {
        if (_values != null) {
            T[][] oldValues = _values;
            int arrayLength = getBits().Length;
            _values = new T[arrayLength][];

            for (int i = old.Length - 1; i >= 0; i--) {
                if (old[i] != null) {
                    int intIndex = old[i].IntIndex;
                    int folded = org.objectfabric.Bits.getFoldedIntIndexFromIntIndex(getBits(), intIndex);

                    if (org.objectfabric.Debug.ENABLED)
                        org.objectfabric.Debug.assertion(_values[folded] == null);

                    _values[folded] = oldValues[i];
                }
            }
        }
    }

    internal override TObject.Version merge(TObject.Version target, TObject.Version next, bool threadPrivate) {
        TArrayVersion<T> source = (TArrayVersion<T>) next;
        TArrayVersion<T> merged = (TArrayVersion<T>) base.merge(target, next, threadPrivate);
        merged.merge(source, false);
        return merged;
    }

    internal override void deepCopy(TObject.Version source_) {
        TArrayVersion<T> source = (TArrayVersion<T>) source_;
        base.deepCopy(source);
        merge(source, true);
    }

    // TODO simplify
    // @SuppressWarnings("cast")
    private void merge(TArrayVersion<T> source, bool deep) {
        bool skip1 = _values == null;

        if (skip1)
            if (getBits() != null && source.getBits() != null)
                if (getBits().Length != source.getBits().Length)
                    skip1 = false;

        if (skip1) {
            if (!source.bitsEmpty() && source._values != null) {
                if (deep) {
                    int arrayLength = source._values.Length;
                    _values = new T[arrayLength][];

                    for (int i = _values.Length - 1; i >= 0; i--) {
                        if (source._values[i] != null) {
                            arrayLength = org.objectfabric.Bits.BITS_PER_UNIT;
                            _values[i] = new T[arrayLength];
                            Platform.arraycopy(source._values[i], 0, _values[i], 0, _values[i].Length);
                        }
                    }
                } else
                    _values = source._values;
            }
        } else {
            org.objectfabric.Bits.Entry[] writes = source.getBits();

            if (writes != null) {
                for (int i = writes.Length - 1; i >= 0; i--) {
                    if (writes[i] != null && writes[i].Value != 0) {
                        if (_values == null) {
                            int arrayLength = getBits().Length;
                            _values = new T[arrayLength][];
                        }

                        int folded = org.objectfabric.Bits.getFoldedIntIndexFromIntIndex(getBits(), writes[i].IntIndex);
                        bool skip2 = false;

                        if (!deep) {
                            skip2 = _values[folded] == null;

                            if (!skip2) // All overwritten
                                skip2 = writes[i].Value == -1 && source._values != null && source._values[i] != null;
                        } else if (_values[folded] == null) {
                            int arrayLength = org.objectfabric.Bits.BITS_PER_UNIT;
                            _values[folded] = new T[arrayLength];
                        }

                        if (skip2)
                            _values[folded] = source._values != null ? source._values[i] : null;
                        else
                            merge(_values[folded], writes[i], source._values != null ? source._values[i] : null);
                    }
                }
            }
        }

        if (org.objectfabric.Debug.ENABLED)
            checkInvariants();
    }

    private static void merge(T[] merged, org.objectfabric.Bits.Entry writes, T[] source) {
        for (int i = org.objectfabric.Bits.BITS_PER_UNIT - 1; i >= 0; i--)
            if (org.objectfabric.Bits.get(writes.Value, i))
                merged[i] = source != null ? source[i] : default(T);
    }

    //

    public override void writeWrite(Writer writer, int index) {
        if (writer.interrupted())
            writer.resume();

        if (IS_TOBJECT) {
            writer.writeTObject((TObject) (object) get(index));

            if (writer.interrupted()) {
                writer.interrupt(null);
                return;
            }
        } else if (typeof(T) == typeof(bool)) {
            if (!writer.canWriteBoolean()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<bool> version = (TArrayVersion<bool>) (object) this;
            writer.writeBoolean(version.get(index));
        } else if (typeof(T) == typeof(byte)) {
            if (!writer.canWriteByte()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<byte> version = (TArrayVersion<byte>) (object) this;
            writer.writeByte(version.get(index));
        } else if (typeof(T) == typeof(char)) {
            if (!writer.canWriteCharacter()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<char> version = (TArrayVersion<char>) (object) this;
            writer.writeCharacter(version.get(index));
        } else if (typeof(T) == typeof(short)) {
            if (!writer.canWriteShort()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<short> version = (TArrayVersion<short>) (object) this;
            writer.writeShort(version.get(index));
        } else if (typeof(T) == typeof(int)) {
            if (!writer.canWriteInteger()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<int> version = (TArrayVersion<int>) (object) this;
            writer.writeInteger(version.get(index));
        } else if (typeof(T) == typeof(long)) {
            if (!writer.canWriteLong()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<long> version = (TArrayVersion<long>) (object) this;
            writer.writeLong(version.get(index));
        } else if (typeof(T) == typeof(float)) {
            if (!writer.canWriteFloat()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<float> version = (TArrayVersion<float>) (object) this;
            writer.writeFloat(version.get(index));
        } else if (typeof(T) == typeof(double)) {
            if (!writer.canWriteDouble()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<double> version = (TArrayVersion<double>) (object) this;
            writer.writeDouble(version.get(index));
        } else if (typeof(T) == typeof(string)) {
            TArrayVersion<string> version = (TArrayVersion<string>) (object) this;
            writer.writeString(version.get(index));

            if (writer.interrupted()) {
                writer.interrupt(null);
                return;
            }
        } else if (typeof(T) == typeof(System.DateTime?)) {
            if (!writer.canWriteDate()) {
                writer.interrupt(null);
                return;
            }

            TArrayVersion<System.DateTime?> version = (TArrayVersion<System.DateTime?>) (object) this;
            writer.writeDate(version.get(index));
        } else if (typeof(T) == typeof(System.Numerics.BigInteger?)) {
            TArrayVersion<System.Numerics.BigInteger?> version = (TArrayVersion<System.Numerics.BigInteger?>) (object) this;
            writer.writeBigInteger(version.get(index));

            if (writer.interrupted()) {
                writer.interrupt(null);
                return;
            }
        } else if (typeof(T) == typeof(decimal?)) {
            TArrayVersion<decimal?> version = (TArrayVersion<decimal?>) (object) this;
            writer.writeDecimal(version.get(index));

            if (writer.interrupted()) {
                writer.interrupt(null);
                return;
            }
        } else if (typeof(T) == typeof(byte[])) {
            TArrayVersion<byte[]> version = (TArrayVersion<byte[]>) (object) this;
            writer.writeBinary(version.get(index));

            if (writer.interrupted()) {
                writer.interrupt(null);
                return;
            }
        } else {
            UnknownObjectSerializer.write(writer, get(index));

            if (writer.interrupted()) {
                writer.interrupt(null);
                return;
            }
        }
    }

    public override void readWrite(Reader reader, int index, object[] versions) {
        if (reader.interrupted())
            reader.resume();

        if (IS_TOBJECT) {
            TObject[] objects = reader.readTObject();

            if (reader.interrupted()) {
                reader.interrupt(null);
                return;
            }

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<T>) versions[i]).set(index, (T) (object) objects[i]);
        } else if (typeof(T) == typeof(bool)) {
            if (!reader.canReadBoolean()) {
                reader.interrupt(null);
                return;
            }

            bool value = reader.readBoolean();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<bool>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(byte)) {
            if (!reader.canReadByte()) {
                reader.interrupt(null);
                return;
            }

            byte value = reader.readByte();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<byte>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(char)) {
            if (!reader.canReadCharacter()) {
                reader.interrupt(null);
                return;
            }

            char value = reader.readCharacter();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<char>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(short)) {
            if (!reader.canReadShort()) {
                reader.interrupt(null);
                return;
            }

            short value = reader.readShort();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<short>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(int)) {
            if (!reader.canReadInteger()) {
                reader.interrupt(null);
                return;
            }

            int value = reader.readInteger();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<int>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(long)) {
            if (!reader.canReadLong()) {
                reader.interrupt(null);
                return;
            }

            long value = reader.readLong();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<long>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(float)) {
            if (!reader.canReadFloat()) {
                reader.interrupt(null);
                return;
            }

            float value = reader.readFloat();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<float>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(double)) {
            if (!reader.canReadDouble()) {
                reader.interrupt(null);
                return;
            }

            double value = reader.readDouble();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<double>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(string)) {
            string value = reader.readString();

            if (reader.interrupted()) {
                reader.interrupt(null);
                return;
            }

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<string>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(System.DateTime?)) {
            if (!reader.canReadDate()) {
                reader.interrupt(null);
                return;
            }

            System.DateTime? value = reader.readDate();

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<System.DateTime?>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(System.Numerics.BigInteger?)) {
            System.Numerics.BigInteger? value = reader.readBigInteger();

            if (reader.interrupted()) {
                reader.interrupt(null);
                return;
            }

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<System.Numerics.BigInteger?>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(decimal?)) {
            decimal? value = reader.readDecimal();

            if (reader.interrupted()) {
                reader.interrupt(null);
                return;
            }

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<decimal?>) versions[i]).set(index, value);
        } else if (typeof(T) == typeof(byte[])) {
            byte[] value = reader.readBinary();

            if (reader.interrupted()) {
                reader.interrupt(null);
                return;
            }

            for (int i = versions.Length - 1; i >= 0; i--)
                ((TArrayVersion<byte[]>) versions[i]).set(index, value);
        } else {
            object o = UnknownObjectSerializer.read(reader);

            if (reader.interrupted()) {
                reader.interrupt(null);
                return;
            }

            for (int i = versions.Length - 1; i >= 0; i--) {
                object value = o;

                if (value is TObject[])
                    value = ((TObject[]) value)[i];

                ((TArrayVersion<T>) versions[i]).set(index, (T) value);
            }
        }
    }

    //

    // @SuppressWarnings("cast")
    internal override void checkInvariants_() {
        base.checkInvariants_();

        if (getBits() != null && getValues() != null)
            org.objectfabric.Debug.assertion(getValues().Length == getBits().Length);
    }
}
}